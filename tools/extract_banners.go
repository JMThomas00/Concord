package main

import (
	"fmt"
	htmlutil "html"
	"log"
	"os"
	"strings"

	"golang.org/x/net/html"
)

type BannerData struct {
	Name string
	Art  string
}

func main() {
	// Read TAAG HTML file
	file, err := os.Open("d:\\Concord\\Text to ASCII Art Generator (TAAG).html")
	if err != nil {
		log.Fatal("Error opening HTML file:", err)
	}
	defer file.Close()

	doc, err := html.Parse(file)
	if err != nil {
		log.Fatal("Error parsing HTML:", err)
	}

	// Extract all banners
	banners := extractBanners(doc)

	log.Printf("Extracted %d banners\n", len(banners))

	// Generate Go source file
	out, err := os.Create("d:\\Concord\\internal\\client\\banners_generated.go")
	if err != nil {
		log.Fatal("Error creating output file:", err)
	}
	defer out.Close()

	// Write package and header
	fmt.Fprintln(out, "package client")
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "// Code generated by tools/extract_banners.go - DO NOT EDIT")
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "var banners = []Banner{")

	// Write each banner
	for _, b := range banners {
		height := strings.Count(b.Art, "\n") + 1
		// Escape the art string for Go source code
		artEscaped := fmt.Sprintf("%q", b.Art)
		fmt.Fprintf(out, "\t{Name: %q, Art: %s, Height: %d},\n", b.Name, artEscaped, height)
	}

	fmt.Fprintln(out, "}")

	log.Printf("Generated banners_generated.go with %d banners\n", len(banners))
}

// extractBanners traverses the HTML tree and extracts font names and ASCII art
func extractBanners(n *html.Node) []BannerData {
	var banners []BannerData
	var fontName string

	var traverse func(*html.Node)
	traverse = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "div" {
			// Check if this is a font name div
			if hasClass(n, "text-left") && hasClass(n, "mt-4") {
				// Extract font name from text content
				fontName = getTextContent(n)
				fontName = strings.TrimSpace(fontName)
			}

			// Check if this is an ASCII art div
			if hasClass(n, "font-mono") && hasClass(n, "whitespace-pre") {
				if fontName != "" {
					// Extract ASCII art
					artHTML := getInnerHTML(n)
					artText := htmlutil.UnescapeString(artHTML)
					artText = strings.TrimSpace(artText)

					// Only add if we have valid data
					if artText != "" {
						banners = append(banners, BannerData{
							Name: fontName,
							Art:  artText,
						})
						fontName = "" // Reset for next banner
					}
				}
			}
		}

		// Traverse children
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			traverse(c)
		}
	}

	traverse(n)
	return banners
}

// hasClass checks if a node has a specific class
func hasClass(n *html.Node, className string) bool {
	for _, attr := range n.Attr {
		if attr.Key == "class" {
			classes := strings.Fields(attr.Val)
			for _, c := range classes {
				if c == className {
					return true
				}
			}
		}
	}
	return false
}

// getTextContent extracts all text content from a node and its children
func getTextContent(n *html.Node) string {
	if n.Type == html.TextNode {
		return n.Data
	}

	var result strings.Builder
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		result.WriteString(getTextContent(c))
	}
	return result.String()
}

// getInnerHTML extracts the inner HTML content as text
func getInnerHTML(n *html.Node) string {
	var result strings.Builder
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		renderNode(&result, c)
	}
	return result.String()
}

// renderNode renders a node to text
func renderNode(w *strings.Builder, n *html.Node) {
	if n.Type == html.TextNode {
		w.WriteString(n.Data)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		renderNode(w, c)
	}
}
